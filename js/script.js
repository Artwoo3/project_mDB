'use strict';

/* Задания на урок:

1) Реализовать функционал, что после заполнения формы и нажатия кнопки "Подтвердить" - 
новый фильм добавляется в список. Страница не должна перезагружаться.
Новый фильм должен добавляться в movieDB.movies.
Для получения доступа к значению input - обращаемся к нему как input.value;
P.S. Здесь есть несколько вариантов решения задачи, принимается любой, но рабочий.

2) Если название фильма больше, чем 21 символ - обрезать его и добавить три точки

3) При клике на мусорную корзину - элемент будет удаляться из списка (сложно)

4) Если в форме стоит галочка "Сделать любимым" - в консоль вывести сообщение: 
"Добавляем любимый фильм"

5) Фильмы должны быть отсортированы по алфавиту */

/* 1) Некоторые дом элементы могут долго появлятся на странице. Возможно, что скрипт начнет 
выполнятся еще до того, как дом структура будет готова. И тогда скрипт не сможет найти
определенные элементы. Что бы такого не случалось в проэктах используется событие 
DOMContentLoaded(). Оно означает, что мы дожидаемся не полной загрузки всех элементов на 
странице, а только построение дом - структуры. Что бы сказать нашему коду что бы он ждал 
загрузки дом - дерева, необходимо выделить весь код, обратиться к document, навесить 
обработчик события и в кавычках прописать это событие, вторым аргументом открыть callback - 
функцию. И в функцию поместить весь код который был до этого. Теперь этот код сработает только
тогда, когда дом - структура загружена. Дальше получаем форму. Еще получаем элементы внутри
формы - это input. input находим уже внутри полученной формы. Кроме этого в одной из задачи
понадобится checkbox. Получаем checkbox опять же внутри нашей формы. Дальше назначим 
обработчик события на нашу форму. Что бы отследить отправку формы есть обработчик события
'submit', вторым аргументом назначаем callback - функцию. Нам также понадобится объект 
события, что бы отменить стандартное поведение браузера когда нажимаем на кнопку отправить 
и страница перезагружается. Дальше нам необходимо узнать, что именно пользователь отметил в 
формеи поставил ли галочку. Это можно сделать обратившись к определенным элементам. То есть 
если хотим получить новый фильм то создаем для этого новую переменную, обращаемся к тому 
инпуту с которым взаимодействовал пользователь - input.value. В свойстве value которое есть 
у инпута, будет содержаться то, что ввел пользователь. Дальше создаем переменную favorite, 
обращаемся к галочке которая может быть либо отмечена, либо нет. Для того что бы получить 
необходимое булиновое значение, необходимо обратиться к галочке .checked. Теперь когда форма
будет подтверждаться, нам необходимо будет создавать новый фильм и помещать в базу данных. И 
сразу отсортируем по алфавиту. Для этого обращаемся к movieDB.movies и используем метод push.
Наши фильмы это массив и тот фильм, который был введен пользователем туда попадает. Когда мы 
запушили новый фильм, нужно отсортировать по алфавиту. С этой задачей справились. У нас уже есть
функционал по созданию новых элементов на основании фильмов. И теперь этот же функционал нужно
переиспользовать в нашей функции. Потому что на этапе когда сабмититься наша новая форма у нас
появляется новый элемент. Для того, что бы несколько раз использовать один и тот же функционал,
необходимо его обернуть в функцию. Создаем новую функцию и во втнутрь помещаем весь функционал.
Только сортировку вынесем наружу. Сделаем эту функцию более универсальной. Пока что мы 
привязываемся к определенным элементам, которые есть на странице, либо есть в определенном
скрипте. Нужно сделать что бы эта функция была полностью независимая, что бы она вызывалась и
только на момент вызова узнавалось с чем она будет работать. Для этого у нас есть аргументы. 
Передаем тула films - это фильмы, с которыми будет работать наша функция и parent - какой 
родительский блок на страничке будет использовать все эти фильмы. Соответсвенно теперь мы все 
это заменяем. Мы говорим, что такой родительский мы будем очищать и в этот же родительский 
элемент мы будем помещать новые фильмы. Таким образом мы отходим от каких то жестко заданых
элементов и наша функция будет узнаать эти элементы только в момент вызова. Помимо этого мы 
функцию будем вызывать только когда нам нужно. Теперь сразу после объявления нашей функции мы ее
вызовем. Во внутрь передаем movieDB.movies как первый аргумент - это фильмы которые мы будем
перебирать. И так же наш parent (movieList) - куда мы будем помещать. Остальные функциональности
тоже стоит обернуть в функции. Например, участок кода который отвечает за удаление рекламы. 
Создаем стрелочную функцию deleteAdv. Сейчас мы опять же привязываемся к какому то элементу. 
Мы уйдем от этого, говорим что передаем аргумент arr который будет определяться уже только в 
момент вызова функции. Сразу вызовем функцию и во внутрь передаем adv. То же самое объединим
в стрелочную функцию makeChanges действия по замене жанра и заднего фона. ызовем ее без 
аргументов. Дальше создадим стрлочную функцию sortArr - она будет принимать в себя какой то 
массив и во внутрь поместим сортировку. Вызоем ее с аргументом movieDB.movies. Так же подставим 
эту функцию в addForm.addEventListener. Теперь возвращаемся к обработчику событий. На основании 
новых данных опять построим список фильмов. Для этого вызываем функцию createMovieList. В конце
нам нужно очистить форму, что бы из нее все данные исчезли. Обращаемся к самой форме и используем
метод .reset(). Мы можем использовать объект события event. При помощи event.target обращаемся
к самому элементу над которым происходит события.
Есть недочет: когда мы просто нажимаем кнопку подтердить то пустые данные записыаются. Когда у
нас ничего не вписано в наш инпут у нас есть свойство value которое будет содержать пустую
строку. По логическому предтавлению пустая строка это false. Если мы напишем условие в которое
поместим newFilm, оно будет ыполнятся когда когда этот инпут заполнен (не пустая строка). 
Помещаем в это условие все действия - пуш, сорт, создание листа. Первая задача решена.

2) Нам нужно взять newFilm и проверить колоичесттво символов которое там будт. Это можно сделать 
прямо в условии. Внутри условия создадим еще одно условие, где проверяем длину newFilm. Если 
будет больше 21 символа опять обращаемся к newFilm и заменяем старое значение на новое. В 
интерполяции обращаемся к значению newFilm и используем метод substring. Вырезаем с 0 позиции до
22 и дальше ставим ...

3) Перейдет в функцию createMovieList. Там нам нужно получить все корзинки и прямо сразу 
переберем при помощи forEach. Дальше будет callback функция с 2 аргументами - это каждая 
отдельная кнопка и нумерация(потому что нужно знать номер поп порядку того элемента который мы 
удаляем. Ведь массив содержит элементы строго по порядку. Внутри обращаемся к каждой корзинке, 
навешиваю обработчик события клика, во внутрь опять запускаем callback функцию и внутри 
обращаюсь к кнопке, обращаемся к родительскому элементу и удаляем его. Помои того еще удаляем его
с базы данных через метод splice и в аргументы помещаем сначала номер, с которого нужно начать, 
а второй это сколько элементов нужно удалить. Нам нужно только 1 элемент из массива удалить.
Но ест косяк - нумерация не удаляется при удалении фильмов. используем рекрсию. Когда происходит
удаление какого то элемента, я хочу что бы вссе элементы оставшиеся они заново перестраивались.
За это отвечает функция  createMovieList. Тогда вызовем ее же внутри. Только movieList 
заменяю на parent, а movieDB.movies на films. При этом мы отвязываемся от коткретных элементов.

5) Когда нажимаю на удалить фильм, сортировка сбиваеться. Сделаем дополнение, когда запускаем
функцию createMovieList, она будет сама внутри себя сортировать элементы. Вызываем внутри функцию
sortArr у помещаем films. 

4) Возвращаемя в обработичк события submit. У нас есть переменная favorite, в нее приходит либо
true либо false. Мы можем просто проверить условие если эта галочка отмечена то выводим  консоль
сообщение. */

const movieDB = {
    movies: [
        "Логан",
        "Лига справедливости",
        "Ла-ла лэнд",
        "Одержимость",
        "Скотт Пилигрим против..."
    ]
};

const adv = document.querySelectorAll('.promo__adv img'),
    poster = document.querySelector('.promo__bg'),
    genre = poster.querySelector('.promo__genre'),
    movieList = document.querySelector('.promo__interactive-list');

adv.forEach(item => {
    item.remove();
});

genre.textContent = 'драма';

poster.style.backgroundImage = "url('img/bg.jpg')";

movieList.innerHTML = '';

movieDB.movies.sort();

movieDB.movies.forEach((film, i) => {
    movieList.innerHTML += `
        <li class="promo__interactive-item">${i + 1} ${film}
            <div class="delete"></div>
        </li>
    `;
});